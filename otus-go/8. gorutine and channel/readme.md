После закрытия вы всегда будете получать zero value и чтение из кнала закончено 
<pre>
close(ch)
</pre>

## Gorutine

* Реализуют механизм “одновременного” выполнения двух разных задач в одной
программе
* Горутины - “легковесные треды” (в противопоставление “тяжелым” тредам ОС)
* Go - за простоту: у горутин “нет” идентификаторов, чтобы ими не злоупотребляли
* Не всегда очевидно, в какой момент горутина будет исполнена
* Новые горутины создаются с помощью конструкции go
* go f() - вызвать функцию f из горутины


### Каналы
* Под капотом - указатель
* Когда использовать небуф.канал? - когда нужно отправить сигнал, синхронизировать две горутины на чтение-записи!
* Когда использовать буф.канал? - когда нужно передать данные, и такой канал не поддерживает синхр-цию чтение-записи!


## Каналы можно сравнить!
Каналы равны только в том случае, если:
у них одинаковые указатели
<pre>
 ch0 := make(chan int)
 ch1 := make(chan int)
 ch2 := ch1
 
 fmt.Println(“ch0 == ch1”, (ch0==ch1))
 fmt.Println(“ch1 == ch2”, (ch1==ch2))
 </pre>


* Каналы позволяют производить синхронизацию и обмен данными между горутинами
* Работаю по принципу FIFO (как очереди) «первым пришёл — первым обслужен».
* Работают со значениями определенного типа (целые, структуры, интерфейсы, каналы и тд)
* под капотом каналов - УКАЗАТЕЛЬ, те. когда мы передаём канал в функцию, то нам не нужно передавать указатель на канал!


* Однонаправленные (только чтение, только запись) и двунаправленные
* Буферизованные и небуферизованные 
* Открытые и закрытые

#### Операции с каналами
* Создание канала
```
ch = make(chan int) // небуферизованный канал
or
ch = make(chan int, 3) // буферизованный канал, где указываем ёмкость канала
```

* Отправление в канал
```
ch <- x
```

* Получение из канала
```
x, ok := <-ch
```

* Закрытие канала
```
close(ch)
```
Чтение из закрытого канала вернет zero value
Запись в закрытый канал вызовет панику!!!!
Закрывал канал тот, который в этот канал пишет!

ЗАКРЫТИЕ КАНАЛА МОЖНО ИСПОЛЬЗОВАТЬ ДЛЯ СИНХРОНИЗАЦИИ!!!!!!!!!!!

### небуферизованный канал
* Отправление в канал блокируется до тех пор, пока не будет выполнено получение
* Получение из канала блокируется до тех пор, пока не выполнится отправление
* часто используются для синхронизации

### Буферизованный канал
* максимальная ёмкость задаётся при вызове make(chan int, 3)
* отправка в канал блокируется только если канал заполнен) в этом отличие между буферизованными и НЕ_буферизованными каналами
* чтение из канала блокируется только если он пуст
* посмотреть ёмкость канала `cap(ch)`
* посмотреть кол-во элементов в канале `len(ch)`
* осторожно! скорее всего `len(ch)` сразу же устареет!!!

### Таймер
таймер сработает через указанное время
```
timer := time.NewTimer(10 * time.Second)

select {
    case: <-ch: // do it
    case: <-timer.C: // do it
}
```

### Тикер
Тикер сработает через раз в заданное кол-во времени
```
ticker := time.NewTicker(10 * time.Second)

for {
    select {
        case: <-ticker.C: // do it
    }
}
```