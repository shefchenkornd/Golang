Области видимости и блоки


Области видимости:
- universe block - весь код проекта
- package block - весь код пакета
- file block -исходный код в файле
- local block - просто {}


Интересное:
* в Го нет дефолтных значений для параметров
* параметры в функцию передаются по значению
* функцию - first class value (те. функцию можно запихнуть в переменную)
<pre>
// функцию можно запихнуть в переменную
f:= func() int {
    return 100
}

fmt.Println(f())
</pre>

## Именованные функции могут быть только в теле пакета и вне другой функции
<pre>
func Greet() int {
    return 100
}
func main() {
	fmt.Println( Greet() )
	
	// или функцию можно объявить так, но через анонимную ф-ю:
	greet := func() int {
	    return 200
	}
	
	fmt.Println( greet() )
}
</pre>


## Вариадические функции
могут быть, т.е. принимать неограниченное кол-во  параметров
<pre>
fmt.Println("one", "two", "three", "four")
someSlice = append(someSlice, "one", "two", "N")
</pre>


<pre>
/**
... - pack operator, он собирает все параметры типа Type
в слайс, и он же их распаковывает.
ТОЛЬКО ПОСЛЕДНИЙ ПАРАМЕТР функции может быть вариадическим.
 */
func Foo(format string, a ...int) int {
	fmt.Println(format)

	s := 0
	for _, i := range a {
		s+=i
	}

	return s
}

func main() {
	s := Foo("int", 1, 2, 3, 4, 5)
	fmt.Printf("%d", s)
}
</pre>

## Замыкание
Замыкание - это особый вид ф-и. Она определена в теле другой ф-и и создаётся каждый раз во время её выполнения.
Синтаксически это выглядит как ф-я, находящаяся целиков в теле другой ф-и. При этом
вложеннаая внутренняя ф-я содержит ссылки на локальные переменные внешней ф-и.

 
## Ошибки

* Ошибка - это тип, реализующий интерфейс error
* Ф-и возвращают ошибки как обычные значения
* По конвенции, ошибка -  последнее возвращаемое функцией значение
* Ошибки обрабатываются проверкой значения (и/или передаются выше через обычный return)

<pre>
    type error interface {
    	Error() string
    }
</pre>

Итого:
* проверяйте ошибки
* лишний раз не логируйте
* проверяйте поведение, а не тип
* ошибки - это значение

## Panic
Panic - это встроенная ф-я, которая останавливает обычный поток управления и начинает паниковать.
Когда ф-я F вызывает panic, выполнение F останавливается, все отложенные ф-и в F выполняются нормально,
затем F возвращает управление вызывающей функции. Для вызывающей функции вызов F ведёт себя как
вызов panic. Процесс продолжается вверх по стеку, пока все функции в текущей го-процедуре не завершат выполнение,
после чего аварийно останавливается программа. Паника может быть вызвана прямым вызовом panic,а также
вследствие ошибок времени выполнения, таких как доступ вне границ массива.

## Recover - аналог catch() в других языках программирования
Recover - это встроенная функция, которая восстанавливает контроль над паникующей го-процедурой.
Recover полезна только внутри отложенного вызова функции. Во время нормального выполнения, recover возвращает nil
и не имеет других эффектов. Если же текущая го-процедура паникует, то вызов recover возвращает
значение, которое было передано panic и восстанавливает нормальное выполнение.

























