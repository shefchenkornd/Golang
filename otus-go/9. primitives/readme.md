О чем будем говорить:

* Мьютексы
* Условные переменные
* Гарантировано одноразовое выполнение
* Pool and WaitGroup
* Модель памяти в Go
* Race-детектор



---
Конкаренс -  "одновременное" выполнение нескольких программ на ОДНОМ процессорном ядре!
В реальном времени в одну единицу времени будет выполняться только одна программа. 


race детектор можно использовать в продакшн, но только чтобы лимит горутин не превышал 8128!
также можно собрать сборку с флагом race-детектор
 `go run -race file.go`
 
## Race condition 
Если не использовать MUTEX, то получим лютую перезапись переменной, и в итоге получаем неверное значение, смотрите ниже:

<pre>
what could go wrong?
| Thread 1      | Thread 2      |    | Integer value
|               |               |    |  0          
| read value    |               | <- |  0
|               | read value    | <- |  0 
| increase value|               |    |  0
|               |increase value |    |  0
| write back    |               |->  |  1
|               | write back    |->  |  1

</pre>

## sync.Mutex
механизм для синхронизации одновременно выполняющихся потоков!



Когда использовать каналы?
* передача данных
* распределение вычислений
* передача асинхронных результатов.

Когда использовать мьютексы?
* кэши
* состояния.



## sync.RWMutex
позволяет читать всем всем горутинам, но записывать разрешает только одной горутине!
 
В обычный мьютекс может заходить только одна горутина


### В map() нельзя писать параллельно!!!!

для этих целей придумали
RWMutex - стандартное решение для map!


!!! RLock() and RUnlock() не сильно будут тормозить программу


defer имеет небольшой оверхед (порядка 50-100 наносекунд), поэтому если у вас код для высоконагруженной системы
и 100 наносекунд имеют значения, то вам может быть выгодней не использовать defer

Методы Load() и Store() должны быть определены для УКАЗАТЕЛЯ на Counters, потому что у нас должен быть указатель на мьютекс в нашей структуре.




